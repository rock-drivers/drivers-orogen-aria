name "mr_control"
# Optionally declare the version number
# version "0.1"

import_types_from "base"
import_types_from "AriaTypes.hpp"
using_library "aria"

# If new data types need to be defined, they have to be put in a separate C++
# header, and this header will be loaded here
# import_types_from "mr_controlType.hpp"

# If the component/deployments use data types that are defined in other oroGen
# projects, these projects should be imported there as well.
# import_types_from "base"

# Declare a new task context (i.e., a component)
#
# The corresponding C++ class can be edited in tasks/Task.hpp and
# tasks/Task.cpp, and will be put in the mr_control namespace.
task_context "Task" do
   # A configuration property (here, a std::string). Its value can be retrieved
   # in the C++ code with # _config_value.get() and _config_value.set(new_value).
   # needs_configuration
   property "serial_port", "/std/string", "/dev/ttyS0"
   property "poweron_boot", "/std/string", "3 6 7 9 10"

   # An input port, i.e. an object from which the component gets data from
   # other components' outputs
   #
   # Data can be retrieved using _input.read(value), which returns true if data
   # was available, and false otherwise. _input.connected() returns if this
   # input is connected to an output or not.
   input_port "transrot_vel", "/base/MotionCommand2D"
   input_port "leftright_vel", "/AriaTypes/commands/Velocity2"
#   input_port "reset_odometry", "bool"
#   input_port "device_power", "/AriaTypes/commands/DevicePower"
#   input_port "direct_command", "/AriaTypes/commands/DirectCommand2Byte"

   # An output port, i.e. an object to which the component pushes data so that
   # it is transmitted to other components' inputs
   #
   # Data can be written using _output.write(value). _output.connected() returns
   # if this output is connected to an input or not.
   output_port "robot_pose", "/base/samples/RigidBodyState"

#   output_port "robot_motion", "/base/MotionCommand2D"
#   output_port "robot_compass", "double"
#   output_port "robot_battery", "double"
#   output_port "robot_temp", "double"
#   output_port "odom_dist", "double"
#   output_port "odom_degr", "double"
#   output_port "enc_left", "int"
#   output_port "enc_right", "int"
   
   output_port "robot_motion", "/AriaTypes/samples/Velocity"
   output_port "robot_motion2", "/AriaTypes/samples/Velocity2"
   output_port "robot_compass", "/AriaTypes/samples/CompassHeading"
   output_port "robot_battery", "/AriaTypes/samples/BatteryLevel"
   output_port "robot_temp", "/AriaTypes/samples/Temperature"
   output_port "robot_odometer", "/AriaTypes/samples/Odometer"
   output_port "robot_encoder", "/AriaTypes/samples/Encoder"
   output_port "robot_bumpers", "/AriaTypes/samples/Bumpers"

   # If you want that component's updateHook() to be executed when the "input"
   # port gets data, uncomment this
   # port_driven "transrot_vel"
   
   # Operations:
   # Reset Odometer
   operation('resetOdometer')
   	
   # Turn on/off Port 'portNr' of the PDB
   operation('controlPDB').
   	argument('portNr', 'int').
   	argument('onoff', 'bool')
   	
   # Send direct Command
   operation('directCommand').
   	argument('MRcmd2byte', '/AriaTypes/commands/DirectCommand2Byte')
   	
   # Set translational and rotational Velocity
   operation('transrotVel').
   	argument('velocities', '/base/MotionCommand2D')
   operation('transrotVel2').
   	argument('translational', 'double'). # in m/s
   	argument('rotational', 'double') #in rad/s
   	
   # Set Velocity for left and right Wheels
   operation('lrVel').
   	argument('left', 'double').
   	argument('right', 'double')
end


# Declares a deployment, i.e. an actual executable that contains various tasks.
deployment "mr_control_test" do
    # This is a test deployment that should not be installed
    do_not_install

    # Declares it as periodic, with a period of 100ms
    task("mr_control", "Task").
        periodic(0.1)
end

deployment "robot_control" do
    task("mr_control", "Task").periodic(0.1)
    add_default_logger
end

